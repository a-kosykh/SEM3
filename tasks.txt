
Лабораторная работа 1: Работа со строками
	Реализовать разбор html-страницы с объявлениями; исходный код страницы доступен в файле avito.html. В результате разбора веб-страницы пользователь должен получить следующие данные: текст объявления, ссылку на объявление, цену, наличие фотографии.
	1.	Предусмотреть возможность сортировки выдачи по цене.
	2.	Предусмотреть возможность фильтрации полученных объявлений по следующим критериям:
	•	цена
	•	наличие ключевого слова в тексте
	•	наличие фотографии
	•	наличие символов английского алфавита в тексте объявления
Лабораторная работа 2: R-valueссылки, семантика перемещения
	1.	Реализовать классы с некопируемыми и неперемещаемыми объектами.
	2.	Реализовать некопируемый перемещаемый класс stack (ограниченного размера) с методами pop, push
	3.	Реализовать некопируемый перемещаемый класс stack для некопируемых неперемещаемых объектов с методами 
	o	pop_emplace, принимающего те же аргументы, что и конструктор хранящегося в нем объекта
	o	head, возвращающего ссылку на верхушку стека
	o	pop_destroy, выполняющего разрушение верхушки стека
Лабораторная работа 3: Работа с файловой системой (часть 1)
	Реализовать программу, выводящую список файлов и директорий по указанному пути. (Аналог утилиты ls).
	На вход программа получает путь к какой-либо директории и должна вернуть следующие данные для всех содержащихся в ней файлов, ссылок и директорий:
	•	Время создания;
	•	Имя;
	•	Права доступа;
	•	Размер.
Лабораторная работа 4: Работа с файловой системой(часть 2)
	Реализовать программу, осуществляющую копирование файла или директории по заданному пути. (Аналог утилиты cp). Программа получает на вход путь исходного файла или директории и путь, куда нужно скопировать. Если на вход подается директория, программа должна рекурсивно копировать все находящиеся в ней файлы и директории.
Лабораторная работа 5: Работа с файловой системой(часть 3)
	Реализовать программу, осуществляющую поиск ключевых слов в файлах. На вход программе подается путь файла или директории и ключевое слово для поиска. Программа должна вернуть список файлов, в которых это слово присутствует.
Лабораторная работа 6:Работа с умными указателями
	1.	Реализуйте функцию обмена значений двух указателей типа unique_ptr,  shared_ptr.
	2.	Создайте реализацию связного списка (linkedlist) с использованием умных указателей.

Лабораторная работа 7: Разработка синхронного клиент-серверного приложения (ECHO-сервер)
	Реализовать ECHO-сервер, выполняющий считывание клиентских запросов до символа '\n', и отправляющий клиенту введенные им же данные. 
	Реализовать клиент, тестирующий функциональность реализованного сервера.
Лабораторная работа 8: Connectionlogger
	Реализовать сервер, выполняющий последовательное считывание имени и фамилии подключенного клиента. После ввода запрошенных данных сервер должен отображать приветствие с указанием переданных данных, и завершать соединение. При подключении клиента с учетными данными "admin-admin" сервер должен отправлять клиенту список соединявшихся с ним пользователей.
	Использовать асинхронные операции.
	Пример работы со стороны клиента:
	----------------------------------
	S > Name?
	U < Username
	S > Surname?
	U < Usersurname
	S > Nice to have you connected, Username Usersurname.
	----------------------------------
	S > Name?
	U < Ivan
	S > Surname?
	U < Ivanoff
	S > Good morning, Ivan Ivanoff!
	----------------------------------
	S > Name?
	U < admin
	S > Surname?
	U < admin
	S > Username Usersurname
		Ivan Ivanoff
	Реализовать клиент, тестирующий функциональность реализованного сервера.
Лабораторная работа 9: RCP
	Реализовать сервер и клиент, обеспечивающие копирование файла с компьютера сервера на компьютер клиента. Пример интерфейса - утилита rcp: https://linux.die.net/man/1/rcp
Лабораторная работа 10: Разработка многопоточного клиент-серверного приложения (чат)

	1.	Создать сокет-acceptor и привязать его к конкретному IP-адресу и порту.
	2.	До внешней команды остановки выполнять цикл:
	•	Ожидать подключения клиента
	•	Принять подключение клиента
	•	Запустить поток, и в нем обрабатывать подключение клиента: 
	o	Ожидать прихода запроса от клиента
	o	Прочитать запрос
	o	Выработать ответ
	o	Отправить ответ всем остальным клиентам
	•	Закрыть соединение и освободить ресурс сокета
Лабораторная 11:async, future, promise
	Описание окружения
	Задан большой текстовый файл F1, в котором встречаются строки {0}, {1}, ...
	Задан файл F2 с задачами вида:
	10 4
	11 3
	30 2
	...
	Задан сервис с интерфейсом:
	// Инициализация сервиса
	voidinitialise();

	// Синхронный сервис вычисления задачи. Длительность: 2s
	intsolveOne(int a, int b);

	// Асинхронный сервис вычисления пакета задач
	// Длительность на задачу: 1s
	// Минимум задач в пакете: 2
	// Максимум задач в пакете: 4
	// Максимум параллельных вычислений: 4
	// Возвращает: идентификатор асинхронной задачи
	intsolveBunch(std::vector<std::pair<int, int>>& bunch); 

	// Получение результата вычисления пакета задач
	// Принимает: идентификатор асинхронной задачи
	// Возвращает: ассоциативный массив вида "номер задачи в пакете: результат вычисления"
	std::map<int, int>getBunchResult(int handler);

	Задача
	Записать в файл F3 содержимое файла F1, заменяя строки {0}, {1}, ... на результаты вычисления соответствующих по порядку следования задач из файла F2.
	Использовать файлы solver.h, solver.cpp, main.cpp:
	1.	Использовать solveOne(). Максимальное количество потоков в приложении: 6.
	2.	Использовать solveBunch() и getBunchResult(). Максимальное количество потоков в приложении: 6.
	Лабораторная работа 12: Разработка асинхронного клиент-серверного приложения(чат)
	1.	Создать сокет-acceptor и привязать его к конкретному IP-адресу и порту.
	2.	Инициализировать асинхронную операцию ожидания поключения
	3.	Запустить один или несколько потоков, в каждом из которых начать выполнение io_service.
	4.	При срабатывании выхода из асинхронной операции ожидания подключения:
	•	Инициировать операцию обмена данными с подключеннным клиентом
	•	Инициировать новую асинхронную операцию ожидания подключения (2)
	5.	Обмен данными с клиентом:
	•	(1) Инициировать асинхронную операцию чтения запроса
	•	(2) При завершении операции чтения запроса обработать запрос и подготовить ответ
	•	(3) Инициировать асинхронную операцию отправки ответа
	•	(4) При завершении операции отправки запроса закрыть соединение и освободить ресурс сокета

Лабораторная 13: Практическое подтверждение сложностных характеристик операций над контейнерами STDC++ (часть 1).
	Произвести практическое подтверждение сложности операций для следующих контейнеров:
	•	std::vector
	•	std::list
	•	std::deque
	•	std::multimap
	•	std::set
	•	std::unordered_map
	Исследуемые операции над контейнерами:
	•	добавление элемента в контейнер
	•	удаление элемента из контейнера
	•	поиск элемента в контейнере
	Замеры приводятся для количества элементов в контейнере: 10, 100, 1000, 10000, 50000, 100000, 500000
	Количество замеров на каждый размер контейнера: 100 (возможно снижение в разы в случае долгой операции).
	По замерам считается среднее значение, сохранение данных производится в текстовом виде, совместимом с форматом таблиц. Ожидается построение графиков по полученным данным.
	Измерение времени
	#include<time.h>

	clock_t start, end;
	double cpu_time_used;

	start = clock();
	… /* Do the work. */
	end = clock();
	cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

Лабораторная 14: Практическое подтверждение сложностных характеристик операций над контейнерами STDC++ (часть 2).
	Произвести практическое подтверждение сложности операций для следующих контейнеров:
	•	std::vector, std::deque: 
	o	доступ к элементу контейнера по индексу
	o	добавление элемента в начало/конец контейнера
	o	различия в сложности добавления элемента в контейнер при копируемых и перемещаемых элементах
	•	std::multimap: 
	o	изменение времени добавления элемента с одним и тем же ключом
	•	std::set: 
	o	различия в поиске методом класса и внешней функцией из <algorithm>
	•	std::unordered_map: 
	o	отслеживание попадания элементов в конкретный bucket (на каждом добавлении фиксировать размер всех bucket)
	o	реализация "плохой" функции хеширования и оценка сложности поиска в случае такой функции
	o	реализация функции хеширования для пользовательского типа
	•	std::unordered_map: 
	o	динамика изменения количества bucket при добавлении элементов в контейнер
	•	std::vector: 
	o	динамика изменения capacity при добавлении элементов в контейнер, удалении элементов из контейнера

	Замеры приводятся для количества элементов в контейнере: 10, 100, 1000, 10000, 50000, 100000, 500000
	Количество замеров на каждый размер контейнера: 100 (возможно снижение в разы в случае долгой операции).
	По замерам считается среднее значение, сохранение данных производится в текстовом виде, совместимом с форматом таблиц. Ожидается построение графиков по полученным данным.

Лабораторная 15: QtWidgetApplication
	Калькулятор
	Создать приложение с графическим интерфейсом, имеющее следующие параметры.
	Главное окно приложения имеет:
	•	два поля ввода типа SpinBox для ввода операндов
	•	поле ввода типа ComboBox для задания операции (+, -, %, *)
	•	3 поля ввода типа RadioButton для задания системы счисления, в которой будет отображаться результат.
	•	кнопки "Посчитать" и "История": 
	o	по нажатии кнопки "Посчитать" в поле "Результат" должна обновляться информация
	o	по нажатии кнопки "История" должно отображаться немодальное диалоговое окно "История".
	•	поле ввода типа CheckBox "Мгновенный расчет" для задания режима: 
	o	пересчет результата по изменении входных данных
	o	пересчет данных по нажатии кнопки "Посчитать"
	При попытке закрытия главного окна должно выводиться модальное диалоговое окно с запросом подтверждения действия.
	Окно "История" имеет:
	•	управляющий элемент ListBox, в котором должны быть отображены все выполненные в ходе работы программы расчеты
	•	кнопка "Восстановить", по нажатии на которую при выбранном пункте истории истории операнды и операция должны заполняться указанными в этом пункте значениями.
	•	поле ввода искомого значения и кнопка "Найти", позволяющие искать в истории какую-либо операцию. Повторное нажатие кнопки должно приводить к поиску следующего употребления. Поиск должен быть циклическим. Если ни одно операции не найдено, должно отображаться окно типа MessageBox с сообщением. Если зажата кнопка "Shift", поиск должен осуществляться в обратном направлении (ищется предыдущее употребление).
	Документация
	http://doc.qt.io/qt-5/qcoreapplication.html
	http://doc.qt.io/qt-5/qguiapplication.html
	http://doc.qt.io/qt-5/qapplication.html
	http://doc.qt.io/qt-5/qtwidgets-index.html
	http://doc.qt.io/qt-5/widget-classes.html#basic-widget-classes
	http://doc.qt.io/qt-5/qwidget.html
	http://doc.qt.io/qt-5/qcheckbox.html
	http://doc.qt.io/qt-5/qcombobox.html
	http://doc.qt.io/qt-5/qlabel.html
	http://doc.qt.io/qt-5/qpushbutton.html
	http://doc.qt.io/qt-5/qradiobutton.html
	http://doc.qt.io/qt-5/qspinbox.html
	http://doc.qt.io/qt-5/qlistview.html
	http://doc.qt.io/qt-5/qdialog.html
	1.	Примеры и руководства
	http://doc.qt.io/qtcreator/creator-writing-program.html
	http://doc.qt.io/qt-5/examples-widgets.html

Лабораторная16: Qt Application: Paint
	Разработка приложения простейшего графического редактора с меню и панелями инструментов, реализующего следующую функциональность:
	•	(PAINT-IT) Добавление/удаление графических объектов
	•	(ROTATE-IT) Поворот выделенного графического объекта
	•	(SCALE) Масштабирование сцены
	•	(COLORIZE-IT) Изменение цвета кисти и пера для объекта
	•	(Z-ORDER) Изменение порядка перекрытия объектов
	•	(CONTEXT-MENU) Управление объектом через его контекстное меню
	•	(COLLIDE) Изменение цвета объекта при коллизии с другим объектом
	•	(SAVE) Сохранение содержимого сцены в файл
	Типы графических объектов:
	•	стандартные объекты: (QGraphicsEllipseItem, QGraphicsPathItem, QGraphicsPolygonItem, QGraphicsRectItem, QGraphicsSimpleTextItem, QGraphicsLineItem)
	•	нестандартный объект (наследуется от QGraphicsItem, поддерживает отслеживание коллизий)
	Требования к графическим объектам: выделяемые, перемещаемые.
	Требования к интерфейсу:
	•	наличие подменю
	•	наличие взаимоисключающих действий (например, цвет кисти может быть либо красный, либо синий)
	Лабораторная работа 17: Аудит/review программного проекта
	Выполнить аудит исходного кода проекта с целью обнаружения и исправления ошибок, которые остались незамеченными в начальной фазе разработки.
	Для review необходимо:
	1.	Сделать fork проекта
	2.	Клонировать проект
	3.	Убедиться, что знаете/умеете его собирать и запускать
	4.	Создать новую ветку review.
	5.	Проанализировать исходный код и найти в нем места, содержащие ошибки, грозящие ошибкой в будущем, свидетельствующие о неправильной архитектуре проекта и т.п.
	6.	Посредством комментариев в исходном коде засвидетельствовать проблему; возможно, предложить решение
	7.	Закоммитить ваши изменения в проекте
	8.	Синхронизовать удаленную версию репозитория с вашей локальной версией
	9.	Сделать pull-request в оригинальный репозиторий проекта.

